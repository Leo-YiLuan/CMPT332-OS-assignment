diff --git a/xv6-riscv/.gitignore b/xv6-riscv/.gitignore
index 07216f3..a51ef3e 100644
--- a/xv6-riscv/.gitignore
+++ b/xv6-riscv/.gitignore
@@ -11,7 +11,6 @@ entryother
 initcode
 initcode.out
 kernelmemfs
-mkfs
 kernel/kernel
 user/usys.S
 .gdbinit
diff --git a/xv6-riscv/Makefile b/xv6-riscv/Makefile
index 7e263cb..4eccc60 100644
--- a/xv6-riscv/Makefile
+++ b/xv6-riscv/Makefile
@@ -115,6 +115,7 @@ mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
 # http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
 .PRECIOUS: %.o
 
+	# CMPT 332 GROUP 22 Change, Fall 2022
 UPROGS=\
 	$U/_cat\
 	$U/_echo\
@@ -132,6 +133,8 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_cowtest\
+	$U/_RRTest\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
@@ -153,7 +156,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 3
+CPUS := 1
 endif
 
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
@@ -170,4 +173,3 @@ qemu: $K/kernel fs.img
 qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
-
diff --git a/xv6-riscv/kernel/defs.h b/xv6-riscv/kernel/defs.h
index 6c3ae5a..cb15c99 100644
--- a/xv6-riscv/kernel/defs.h
+++ b/xv6-riscv/kernel/defs.h
@@ -63,6 +63,10 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void page_ref_inc(uint64 pa);
+void page_ref_dec(uint64 pa);
+int page_ref_count(uint64 pa);
 
 /* log.c */
 void            initlog(int, struct superblock*);
@@ -106,6 +110,10 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void            queueinit(void);
+int             nice(int);
+int             getpriority(void);
 
 /* swtch.S */
 void            swtch(struct context*, struct context*);
@@ -173,6 +181,8 @@ uint64          walkaddr(pagetable_t, uint64);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+int handle_pagefault(pagetable_t, uint64);
 
 /* plic.c */
 void            plicinit(void);
diff --git a/xv6-riscv/kernel/kalloc.c b/xv6-riscv/kernel/kalloc.c
index e9e70b9..5ad882a 100644
--- a/xv6-riscv/kernel/kalloc.c
+++ b/xv6-riscv/kernel/kalloc.c
@@ -9,6 +9,12 @@
 #include "riscv.h"
 #include "defs.h"
 
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void page_ref_inc(uint64 pa);
+void page_ref_dec(uint64 pa);
+void page_ref_set(uint64 pa, uint8 val);
+extern char trampoline[]; /* trampoline.S */
+
 void freerange(void *pa_start, void *pa_end);
 
 extern char end[]; /* first address after kernel. */
@@ -21,13 +27,18 @@ struct run {
 struct {
   struct spinlock lock;
   struct run *freelist;
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  uint64 freecount;
+  uint8 ref_map[PHYSTOP / PGSIZE];
 } kmem;
 
 void
 kinit()
 {
   initlock(&kmem.lock, "kmem");
-  freerange(end, (void*)PHYSTOP);
+  freerange((void*)end, (void*)PHYSTOP);
+  /* Trampoline page is special, not allocated normally, set manually. */
+  page_ref_set((uint64)trampoline, 64);
 }
 
 void
@@ -51,6 +62,10 @@ kfree(void *pa)
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
 
+  if (page_ref_count((uint64)pa) > 1) {
+    panic("kfree freeing page with ref count > 1");
+  }
+
   /* Fill with junk to catch dangling refs. */
   memset(pa, 1, PGSIZE);
 
@@ -59,7 +74,12 @@ kfree(void *pa)
   acquire(&kmem.lock);
   r->next = kmem.freelist;
   kmem.freelist = r;
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  kmem.freecount++;
   release(&kmem.lock);
+
+
+  page_ref_set((uint64)r, 0);
 }
 
 /* Allocate one 4096-byte page of physical memory. */
@@ -72,11 +92,98 @@ kalloc(void)
 
   acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r)
+  if(r) {
     kmem.freelist = r->next;
+    /* CMPT 332 GROUP 22 Change, Fall 2022 */
+    kmem.freecount--;
+  }
   release(&kmem.lock);
 
-  if(r)
+  if(r) {
+    /* CMPT 332 GROUP 22 Change, Fall 2022 */
+    // Set ref count to 1, someone must have asked for it.
+    page_ref_set((uint64)r, 1);
     memset((char*)r, 5, PGSIZE); /* fill with junk */
+  }
   return (void*)r;
 }
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void
+page_ref_inc(uint64 pa) {
+  uint64 frameNum = ((pa >> PGSHIFT) << PGSHIFT) / PGSIZE;
+
+  if (frameNum < 0 || (frameNum > (PHYSTOP / PGSIZE))) {
+    panic("page_ref_inc invalid frame number");
+  }
+
+  acquire(&kmem.lock);
+  if (kmem.ref_map[frameNum] >= 64) {
+    panic("page_ref_inc increment past 64");
+  }
+  kmem.ref_map[frameNum]++;
+  release(&kmem.lock);
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void
+page_ref_dec(uint64 pa) {
+  uint64 frameNum = ((pa >> PGSHIFT) << PGSHIFT) / PGSIZE;
+
+  if (frameNum < 0 || (frameNum > (PHYSTOP / PGSIZE))) {
+    panic("page_ref_dec invalid frame number");
+  }
+
+  acquire(&kmem.lock);
+  if ((kmem.ref_map[frameNum] - 1) >= 64) {
+    panic("page_ref_dec decrement below 0, underflow");
+  }
+  kmem.ref_map[frameNum]--;
+  release(&kmem.lock);
+
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+int
+page_ref_count(uint64 pa) {
+  int refCount = 0;
+  uint64 frameNum = ((pa >> PGSHIFT) << PGSHIFT) / PGSIZE;
+
+  if (frameNum < 0 || (frameNum > (PHYSTOP / PGSIZE))) {
+    panic("page_ref_count invalid frame number");
+  }
+
+  acquire(&kmem.lock);
+  refCount = kmem.ref_map[frameNum];
+  release(&kmem.lock);
+
+  return refCount;
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void
+page_ref_set(uint64 pa, uint8 val) {
+  uint64 frameNum = ((pa >> PGSHIFT) << PGSHIFT) / PGSIZE;
+
+  if (frameNum < 0 || (frameNum > (PHYSTOP / PGSIZE))) {
+    panic("page_ref_set invalid frame number");
+  }
+  if (val < 0 || val > 64) {
+    panic("page_ref_set val out of range");
+  }
+
+  acquire(&kmem.lock);
+  kmem.ref_map[frameNum] = val;
+  release(&kmem.lock);
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+uint64
+sys_getNumPages(void) {
+  uint64 res = 0;
+  acquire(&kmem.lock);
+  res = kmem.freecount;
+  release(&kmem.lock);
+
+  return res;
+}
diff --git a/xv6-riscv/kernel/main.c b/xv6-riscv/kernel/main.c
index 078d3ec..c2c355b 100644
--- a/xv6-riscv/kernel/main.c
+++ b/xv6-riscv/kernel/main.c
@@ -28,6 +28,8 @@ main()
     iinit();         /* inode table */
     fileinit();      /* file table */
     virtio_disk_init(); /* emulated hard disk */
+    /* CMPT 332 GROUP 22 Change, Fall 2022 */
+    queueinit();     /* initialize priority queues */
     userinit();      /* first user process */
     __sync_synchronize();
     started = 1;
diff --git a/xv6-riscv/kernel/proc.c b/xv6-riscv/kernel/proc.c
index cc50132..beed3dc 100644
--- a/xv6-riscv/kernel/proc.c
+++ b/xv6-riscv/kernel/proc.c
@@ -5,7 +5,6 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
-
 struct cpu cpus[NCPU];
 
 struct proc proc[NPROC];
@@ -14,12 +13,20 @@ struct proc *initproc;
 
 int nextpid = 1;
 struct spinlock pid_lock;
-
+struct spinlock queue_lock;
 extern void forkret(void);
 static void freeproc(struct proc *p);
 
 extern char trampoline[]; /* trampoline.S */
 
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+QUEUE queues[MAX_LISTS];
+QUEUE *freeQueues = &queues[0];
+
+NODE nodes[MAX_NODES];
+NODE *freeNodes = &nodes[0];
+
+QUEUE *prioQueue[MAX_LISTS];
 /* helps ensure that wakeups of wait()ing */
 /* parents are not lost. helps obey the */
 /* memory model when using p->parent. */
@@ -51,6 +58,7 @@ procinit(void)
 
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
+  initlock(&queue_lock, "queue_lock");
   for(p = proc; p < &proc[NPROC]; p++) {
       initlock(&p->lock, "proc");
       p->state = UNUSED;
@@ -245,12 +253,20 @@ userinit(void)
   /* prepare for the very first "return" from kernel to user. */
   p->trapframe->epc = 0;      /* user program counter */
   p->trapframe->sp = PGSIZE;  /* user stack pointer */
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  p->sleeptime = 0;
+  p->runtime = 0;
+  p->priority = 0;
+  p->ratio = 0;
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
   p->state = RUNNABLE;
-
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  acquire(&queue_lock);
+  ListPrepend(prioQueue[p -> priority],p);
+  release(&queue_lock);
   release(&p->lock);
 }
 
@@ -302,6 +318,12 @@ fork(void)
   /* Cause fork to return 0 in the child. */
   np->trapframe->a0 = 0;
 
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  np->priority = p->priority;
+  np->runtime = 0;
+  np->sleeptime = 0;
+  np->ratio = 0;
+
   /* increment reference counts on open file descriptors. */
   for(i = 0; i < NOFILE; i++)
     if(p->ofile[i])
@@ -320,6 +342,10 @@ fork(void)
 
   acquire(&np->lock);
   np->state = RUNNABLE;
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  acquire(&queue_lock);
+  ListPrepend(prioQueue[np -> priority],np);
+  release(&queue_lock);
   release(&np->lock);
 
   return pid;
@@ -441,32 +467,45 @@ wait(uint64 addr)
 /*  - swtch to start running that process. */
 /*  - eventually that process transfers control */
 /*    via swtch back to the scheduler. */
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
 void
 scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
-  
   c->proc = 0;
+  int priority;
   for(;;){
     /* Avoid deadlock by ensuring that devices can interrupt. */
     intr_on();
+    for (priority = 0; priority < 5; priority++){
+      acquire(&queue_lock);
+        if (ListCount(prioQueue[priority])==0) {
+          release(&queue_lock);
+          continue;
+        }
+        p = ListTrim(prioQueue[priority]);
+        release(&queue_lock);
 
-    for(p = proc; p < &proc[NPROC]; p++) {
         acquire(&p->lock);
-      if(p->state == RUNNABLE) {
-        /* Switch to chosen process.  It is the process's job */
-        /* to release its lock and then reacquire it */
-        /* before jumping back to us. */
+
         p->state = RUNNING;
+
+        /* Uncomment that will test inside the scheduler */
+
+        // printf("Process %d, priority %d,  runtime %d, sleeptime %d\n"
+        // ,p->pid ,p->priority, p->runtime, p->sleeptime );
+
         c->proc = p;
         swtch(&c->context, &p->context);
 
         /* Process is done running for now. */
         /* It should have changed its p->state before coming back. */
         c->proc = 0;
-      }
         release(&p->lock);
+
+        break;
       }
   }
 }
@@ -505,6 +544,10 @@ yield(void)
   struct proc *p = myproc();
   acquire(&p->lock);
   p->state = RUNNABLE;
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  acquire(&queue_lock);
+  ListPrepend(prioQueue[p -> priority],p);
+  release(&queue_lock);
   sched();
   release(&p->lock);
 }
@@ -573,6 +616,10 @@ wakeup(void *chan)
       acquire(&p->lock);
       if(p->state == SLEEPING && p->chan == chan) {
         p->state = RUNNABLE;
+        /* CMPT 332 GROUP 22 Change, Fall 2022 */
+        acquire(&queue_lock);
+        ListPrepend(prioQueue[p -> priority],p);
+        release(&queue_lock);
       }
       release(&p->lock);
     }
@@ -594,6 +641,10 @@ kill(int pid)
       if(p->state == SLEEPING){
         /* Wake process from sleep(). */
         p->state = RUNNABLE;
+        /* CMPT 332 GROUP 22 Change, Fall 2022 */
+        acquire(&queue_lock);
+        ListPrepend(prioQueue[p -> priority],p);
+        release(&queue_lock);
       }
       release(&p->lock);
       return 0;
@@ -681,3 +732,198 @@ procdump(void)
     printf("\n");
   }
 }
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+int
+nice(int incr) {
+    struct proc *p;
+    int newprio;
+    p = myproc();
+    newprio = p->priority - incr;
+    if (newprio < 0 || newprio > 4) {
+      return -1;
+    }
+    p->priority -= incr;
+    return 1;
+
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+int
+getpriority(){
+    struct proc *p;
+    p = myproc();
+    return p->priority;
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void
+updatetick() {
+  struct proc *p;
+  for(p = &proc[0]; p < &proc[NPROC]; p++){
+    acquire(&p->lock);
+    if (p->state == RUNNING) {
+      p->runtime ++;
+      p->ratio = ((float)p->runtime + 3) / ((float)p->sleeptime + 3);
+
+      if (p->ratio > 1.8) {
+        if (p->priority < 4) {
+          p->priority ++;
+
+        }
+
+        p->runtime = 0;
+        p->sleeptime = 0;
+      }
+    }
+    if (p->state == SLEEPING) {
+      p->sleeptime ++;
+      p->ratio = ((float)p->sleeptime + 3) / ((float)p->runtime + 3);
+      if (p->ratio > 1.8) {
+        if (p->priority > 0) {
+          p->priority --;
+
+        }
+        p->runtime = 0;
+        p->sleeptime = 0;
+      }
+    }
+
+    release(&p->lock);
+
+  }
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void
+queueinit() {
+    int i;
+    for (i = 0; i < MAX_LISTS; i++) {
+        prioQueue[i] = ListCreate();
+    }
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+QUEUE*
+ListCreate(){
+    static int initialized = 0;
+    QUEUE *list = NULL;
+
+    if (!initialized) {
+        /* First time library initialization. */
+        int i = 0;
+        int j = 0;
+        for (i = 0; i < MAX_LISTS - 1; i++) {
+            /*
+                For each entry, we re-interpret it as a LIST**,
+                then store the address of the next free entry in that pointer.
+                This gives us the effect of a very simple linked list
+                of free entries stored within the entries themselves.
+                This means no additional storage is necessary.
+            */
+            /* Reinterpret cast this LIST* as a LIST** */
+            QUEUE **next = (QUEUE**)&queues[i];
+            /* Dereference and store the next entry in the chain */
+            *next = &queues[i+1];
+        }
+        for (j = 0; j < MAX_NODES - 1; j++) {
+            /* Same as above. */
+            NODE **next = (NODE**)&nodes[j];
+            *next = &nodes[j+1];
+        }
+        initialized = 1;
+    }
+
+    if (freeQueues == NULL) {
+        /* Out of memory! */
+        return NULL;
+    }
+
+    /*
+     Pull a new list off the stack.
+     Then set the next free entry to be the top of the stack.
+    */
+    list = freeQueues;
+    freeQueues = *(QUEUE**)freeQueues;
+    memset(list, 0, sizeof(QUEUE));
+
+    return list;
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+int
+ListPrepend(QUEUE *list, void *item){
+    NODE *node = NULL;
+    if (list == NULL){
+        return -1;
+    }
+    if (freeNodes == NULL) {
+        /* Out of memory! */
+        return -1;
+    }
+    /* Grab a new node */
+    node = freeNodes;
+    freeNodes = *(NODE**)freeNodes;
+    memset(node, 0, sizeof(NODE));
+
+    if (list->listCount == 0) {
+        /* Empty list, just add the node simply. */
+        list->currNodep = node;
+        list->lastNodep = node;
+        list->firstNodep = node;
+    } else {
+        node->next = list->firstNodep;
+        list->firstNodep->prev = node;
+        list->firstNodep = node;
+        list->currNodep = node;
+    }
+
+    list->listCount += 1;
+    node->item = item;
+
+    return 0;
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+void*
+ListTrim(QUEUE *list){
+    void *item;
+    NODE *removeNode;
+
+    if (list == NULL){
+        printf("Error in procedure ListTrim(): Invalid parameter list \n");
+        return NULL;
+    }
+    if (list->listCount == 0) {
+        return NULL;
+    }
+
+    item = list->lastNodep->item;
+    removeNode = list->lastNodep;
+    if (list->listCount == 1) {
+      *(NODE**)removeNode = freeNodes;
+      freeNodes = removeNode;
+      memset(list,0,sizeof(QUEUE));
+    }else{
+      removeNode->prev->next = NULL;
+      list->lastNodep = removeNode->prev;
+      list->currNodep = list->lastNodep;
+      *(NODE**)removeNode = freeNodes;
+      freeNodes = removeNode;
+      list->listCount --;
+    }
+
+
+    return item;
+
+}
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+int
+ListCount(QUEUE *list){
+    if (list == NULL){
+        return -1;
+    }
+
+    return list->listCount;
+}
diff --git a/xv6-riscv/kernel/proc.h b/xv6-riscv/kernel/proc.h
index 1d7d309..29b38dd 100644
--- a/xv6-riscv/kernel/proc.h
+++ b/xv6-riscv/kernel/proc.h
@@ -104,4 +104,36 @@ struct proc {
   struct file *ofile[NOFILE];  /* Open files */
   struct inode *cwd;           /* Current directory */
   char name[16];               /* Process name (debugging) */
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+  int priority;
+  int runtime;
+  int sleeptime;
+  float ratio;
+};
+
+#define MAX_LISTS 5
+#define MAX_NODES 64
+#define NULL 0
+
+typedef struct NODE NODE;
+struct NODE {
+		void *item;
+		NODE *next;
+    NODE *prev;
 };
+
+typedef struct QUEUE QUEUE;
+struct QUEUE
+{
+    NODE *currNodep;
+    NODE *firstNodep;
+    NODE *lastNodep;
+    int listCount;
+};
+
+QUEUE *ListCreate();
+int ListCount(QUEUE *);
+int ListPrepend(QUEUE *, void *);
+void *ListTrim(QUEUE *);
+void updatetick();
diff --git a/xv6-riscv/kernel/syscall.c b/xv6-riscv/kernel/syscall.c
index 5ae08cc..51aa33b 100644
--- a/xv6-riscv/kernel/syscall.c
+++ b/xv6-riscv/kernel/syscall.c
@@ -101,6 +101,10 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+extern uint64 sys_getNumPages(void);
+extern uint64 sys_nice(void);
+extern uint64 sys_getpriority(void);
 
 /* An array mapping syscall numbers from syscall.h */
 /* to the function that handles the system call. */
@@ -126,6 +130,10 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+[SYS_getNumPages] sys_getNumPages,
+[SYS_nice] sys_nice,
+[SYS_getpriority] sys_getpriority
 };
 
 void
diff --git a/xv6-riscv/kernel/syscall.h b/xv6-riscv/kernel/syscall.h
index 95eab25..3c46a46 100644
--- a/xv6-riscv/kernel/syscall.h
+++ b/xv6-riscv/kernel/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+#define SYS_getNumPages 22
+#define SYS_nice 23
+#define SYS_getpriority 24
diff --git a/xv6-riscv/kernel/sysproc.c b/xv6-riscv/kernel/sysproc.c
index 63b9f42..18af934 100644
--- a/xv6-riscv/kernel/sysproc.c
+++ b/xv6-riscv/kernel/sysproc.c
@@ -89,3 +89,16 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+uint64
+sys_nice(void){
+  uint64 incr;
+  argaddr(0, &incr);
+  return nice(incr);
+}
+
+uint64 
+sys_getpriority(){
+  return getpriority();
+}
diff --git a/xv6-riscv/kernel/trap.c b/xv6-riscv/kernel/trap.c
index 9c7a587..cfc123f 100644
--- a/xv6-riscv/kernel/trap.c
+++ b/xv6-riscv/kernel/trap.c
@@ -10,7 +10,6 @@ struct spinlock tickslock;
 uint ticks;
 
 extern char trampoline[], uservec[], userret[];
-
 /* in kernelvec.S, calls kerneltrap(). */
 void kernelvec();
 
@@ -65,6 +64,22 @@ usertrap(void)
     intr_on();
 
     syscall();
+  } else if (r_scause() == 15) {
+    /* CMPT 332 GROUP 22 Change, Fall 2022 */
+    // Handle a page fault on data write/store
+
+    if(killed(p))
+      exit(-1);
+
+    int res = handle_pagefault(p->pagetable, r_stval());
+    if (res == -1) {
+      printf("usertrap(): Page fault on invalid address. pid = %d, addr = %p\n", p->pid, r_stval());
+      setkilled(p);
+    } else if (res == -2) {
+      printf("usertrap(): Page fault could not COW because we are out of physical memory. "
+              " Killing pid %d instead...\n", p->pid);
+      setkilled(p);
+    }
   } else if((which_dev = devintr()) != 0){
     /* ok */
   } else {
@@ -165,6 +180,8 @@ clockintr()
 {
   acquire(&tickslock);
   ticks++;
+  /* CMPT 332 GROUP 22 Change, Fall 2022 */
+  updatetick();
   wakeup(&ticks);
   release(&tickslock);
 }
@@ -218,4 +235,3 @@ devintr()
     return 0;
   }
 }
-
diff --git a/xv6-riscv/kernel/vm.c b/xv6-riscv/kernel/vm.c
index 6f72356..3cbf3fd 100644
--- a/xv6-riscv/kernel/vm.c
+++ b/xv6-riscv/kernel/vm.c
@@ -153,8 +153,8 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
   for(;;){
     if((pte = walk(pagetable, a, 1)) == 0)
       return -1;
-    if(*pte & PTE_V)
-      panic("mappages: remap");
+    /* CMPT 332 GROUP 22 Change, Fall 2022 */
+    /* Allow remaps. */
     *pte = PA2PTE(pa) | perm | PTE_V;
     if(a == last)
       break;
@@ -167,11 +167,14 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 /* Remove npages of mappings starting from va. va must be */
 /* page-aligned. The mappings must exist. */
 /* Optionally free the physical memory. */
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
 void
 uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 {
   uint64 a;
   pte_t *pte;
+  int save_free = do_free;
 
   if((va % PGSIZE) != 0)
     panic("uvmunmap: not aligned");
@@ -183,8 +186,16 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
       panic("uvmunmap: not mapped");
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
-    if(do_free){
+
+    // If ref count is greater than 1, we can't free.
     uint64 pa = PTE2PA(*pte);
+    do_free = (page_ref_count(pa) > 1) ? 0 : save_free;
+    // Decrement ref count.
+    // Trampoline is a special count, don't dec it.
+    if (va != TRAMPOLINE) {
+      page_ref_dec(pa);
+    }
+    if(do_free){
       kfree((void*)pa);
     }
     *pte = 0;
@@ -302,13 +313,16 @@ uvmfree(pagetable_t pagetable, uint64 sz)
 /* physical memory. */
 /* returns 0 on success, -1 on failure. */
 /* frees any allocated pages on failure. */
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+/* Modified this thread - removed physical page allocation,
+   and increment ref count if successfully remapping. */
 int
 uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 {
   pte_t *pte;
   uint64 pa, i;
   uint flags;
-  char *mem;
 
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
@@ -317,19 +331,21 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
       panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
-      goto err;
+    // Modify flags so the page is read-only in both
+    // child and parent.
+    flags = flags & ~(PTE_W);
+    *pte = PA2PTE(pa) | flags;
+    if(mappages(new, i, PGSIZE, pa, flags) != 0){
+      uvmunmap(new, 0, i / PGSIZE, 1);
+      return -1;
     }
+    // Flush the TLB
+    sfence_vma();
+    // Increment the ref count now that we successfully
+    // have two procs looking at the same physical page.
+    page_ref_inc(pa);
   }
   return 0;
-
- err:
-  uvmunmap(new, 0, i / PGSIZE, 1);
-  return -1;
 }
 
 /* mark a PTE invalid for user access. */
@@ -348,12 +364,27 @@ uvmclear(pagetable_t pagetable, uint64 va)
 /* Copy from kernel to user. */
 /* Copy len bytes from src to virtual address dstva in a given page table. */
 /* Return 0 on success, -1 on error. */
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+/* We aren't getting a pagefault because this call occurs in kernel mode,
+   so instead we fake it. */
 int
 copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 {
   uint64 n, va0, pa0;
+  /* Have to perform this early, to catch invalid addresses */
+  va0 = PGROUNDDOWN(dstva);
+  pa0 = walkaddr(pagetable, va0);
+  if(pa0 == 0) {
+    return -1;
+  }
 
   while(len > 0){
+    pte_t *pte = walk(pagetable, dstva, 0);
+    // Have to perform a COW action.
+    if (!(PTE_FLAGS(*pte) & PTE_W)) {
+      handle_pagefault(pagetable, dstva);
+    }
+
     va0 = PGROUNDDOWN(dstva);
     pa0 = walkaddr(pagetable, va0);
     if(pa0 == 0)
@@ -437,3 +468,64 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+int
+handle_pagefault(pagetable_t table, uint64 va) {
+  if (va >= MAXVA) {
+    // We could normally test this by checking PTE_V,
+    // but in order to check that we need to walk the
+    // page table, and walk() wont let us walk on
+    // a completely invalid address.
+    // So we test early.
+    return -1;
+  }
+
+  // Get faulting address and pagetable
+  uint64 vaAligned = PGROUNDDOWN(va);
+  pte_t *pte = walk(table, va, 0);
+  uint64 pa = PTE2PA(*pte);
+
+  // Check if the faulting address is valid
+  if((*pte & PTE_V) == 0) {
+    // Invalid virtual address!
+    return -1;
+  } else if (*pte & PTE_X) {
+    // This is a code page, we shouldn't be allowed to modify it.
+    // This check is needed to pass the "textwrite" usertest,
+    // otherwise we inadvertantly set code pages to PTE_W.
+    return -1;
+  }
+
+  if (page_ref_count(pa) > 1) {
+    // Create a new physical page.
+    char *newPage;
+    if((newPage = kalloc()) == 0) {
+      // Out of memory, we have no choice but to bail on this proc.
+      // Initially we just used a panic, but that caused the execout
+      // test to fail.
+      return -2;
+    }
+
+    // Move data into new page.
+    memmove(newPage, (char*)pa, PGSIZE);
+
+    // Map the newly constructed copy into the same spot,
+    // now with writeable perms.
+    mappages(table, vaAligned, PGSIZE, (uint64)newPage,
+    PTE_FLAGS(*pte) | PTE_W);
+    if (pa != TRAMPOLINE) { page_ref_dec(pa); }
+    // Flush TLB
+    sfence_vma();
+  } else {
+    // This must be the parent, as they have only 1 ref left.
+    // We can just modify the permissions to let them write to it.
+    //printf("Page has only 1 refcount, simply enable writing perm.\n");
+    uint flags = PTE_FLAGS(*pte);
+    flags = flags | PTE_W;
+    *pte = PA2PTE(pa) | flags;
+    // Flush TLB
+    sfence_vma();
+  }
+  return 0;
+}
diff --git a/xv6-riscv/mkfs/mkfs.c b/xv6-riscv/mkfs/mkfs.c
new file mode 100644
index 0000000..acdd8f2
--- /dev/null
+++ b/xv6-riscv/mkfs/mkfs.c
@@ -0,0 +1,301 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <assert.h>
+
+#define stat xv6_stat  /* avoid clash with host struct stat */
+#include "kernel/types.h"
+#include "kernel/fs.h"
+#include "kernel/stat.h"
+#include "kernel/param.h"
+
+#ifndef static_assert
+#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+#endif
+
+#define NINODES 200
+
+/* Disk layout: */
+/* [ boot block | sb block | log | inode blocks | free bit map | data blocks ] */
+
+int nbitmap = FSSIZE/(BSIZE*8) + 1;
+int ninodeblocks = NINODES / IPB + 1;
+int nlog = LOGSIZE;
+int nmeta;    /* Number of meta blocks (boot, sb, nlog, inode, bitmap) */
+int nblocks;  /* Number of data blocks */
+
+int fsfd;
+struct superblock sb;
+char zeroes[BSIZE];
+uint freeinode = 1;
+uint freeblock;
+
+
+void balloc(int);
+void wsect(uint, void*);
+void winode(uint, struct dinode*);
+void rinode(uint inum, struct dinode *ip);
+void rsect(uint sec, void *buf);
+uint ialloc(ushort type);
+void iappend(uint inum, void *p, int n);
+void die(const char *);
+
+/* convert to riscv byte order */
+ushort
+xshort(ushort x)
+{
+  ushort y;
+  uchar *a = (uchar*)&y;
+  a[0] = x;
+  a[1] = x >> 8;
+  return y;
+}
+
+uint
+xint(uint x)
+{
+  uint y;
+  uchar *a = (uchar*)&y;
+  a[0] = x;
+  a[1] = x >> 8;
+  a[2] = x >> 16;
+  a[3] = x >> 24;
+  return y;
+}
+
+int
+main(int argc, char *argv[])
+{
+  int i, cc, fd;
+  uint rootino, inum, off;
+  struct dirent de;
+  char buf[BSIZE];
+  struct dinode din;
+
+
+  static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
+
+  if(argc < 2){
+    fprintf(stderr, "Usage: mkfs fs.img files...\n");
+    exit(1);
+  }
+
+  assert((BSIZE % sizeof(struct dinode)) == 0);
+  assert((BSIZE % sizeof(struct dirent)) == 0);
+
+  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
+  if(fsfd < 0)
+    die(argv[1]);
+
+  /* 1 fs block = 1 disk sector */
+  nmeta = 2 + nlog + ninodeblocks + nbitmap;
+  nblocks = FSSIZE - nmeta;
+
+  sb.magic = FSMAGIC;
+  sb.size = xint(FSSIZE);
+  sb.nblocks = xint(nblocks);
+  sb.ninodes = xint(NINODES);
+  sb.nlog = xint(nlog);
+  sb.logstart = xint(2);
+  sb.inodestart = xint(2+nlog);
+  sb.bmapstart = xint(2+nlog+ninodeblocks);
+
+  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
+         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
+
+  freeblock = nmeta;     /* the first free block that we can allocate */
+
+  for(i = 0; i < FSSIZE; i++)
+    wsect(i, zeroes);
+
+  memset(buf, 0, sizeof(buf));
+  memmove(buf, &sb, sizeof(sb));
+  wsect(1, buf);
+
+  rootino = ialloc(T_DIR);
+  assert(rootino == ROOTINO);
+
+  bzero(&de, sizeof(de));
+  de.inum = xshort(rootino);
+  strcpy(de.name, ".");
+  iappend(rootino, &de, sizeof(de));
+
+  bzero(&de, sizeof(de));
+  de.inum = xshort(rootino);
+  strcpy(de.name, "..");
+  iappend(rootino, &de, sizeof(de));
+
+  for(i = 2; i < argc; i++){
+    /* get rid of "user/" */
+    char *shortname;
+    if(strncmp(argv[i], "user/", 5) == 0)
+      shortname = argv[i] + 5;
+    else
+      shortname = argv[i];
+    
+    assert(index(shortname, '/') == 0);
+
+    if((fd = open(argv[i], 0)) < 0)
+      die(argv[i]);
+
+    /* Skip leading _ in name when writing to file system. */
+    /* The binaries are named _rm, _cat, etc. to keep the */
+    /* build operating system from trying to execute them */
+    /* in place of system binaries like rm and cat. */
+    if(shortname[0] == '_')
+      shortname += 1;
+
+    inum = ialloc(T_FILE);
+
+    bzero(&de, sizeof(de));
+    de.inum = xshort(inum);
+    strncpy(de.name, shortname, DIRSIZ);
+    iappend(rootino, &de, sizeof(de));
+
+    while((cc = read(fd, buf, sizeof(buf))) > 0)
+      iappend(inum, buf, cc);
+
+    close(fd);
+  }
+
+  /* fix size of root inode dir */
+  rinode(rootino, &din);
+  off = xint(din.size);
+  off = ((off/BSIZE) + 1) * BSIZE;
+  din.size = xint(off);
+  winode(rootino, &din);
+
+  balloc(freeblock);
+
+  exit(0);
+}
+
+void
+wsect(uint sec, void *buf)
+{
+  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE)
+    die("lseek");
+  if(write(fsfd, buf, BSIZE) != BSIZE)
+    die("write");
+}
+
+void
+winode(uint inum, struct dinode *ip)
+{
+  char buf[BSIZE];
+  uint bn;
+  struct dinode *dip;
+
+  bn = IBLOCK(inum, sb);
+  rsect(bn, buf);
+  dip = ((struct dinode*)buf) + (inum % IPB);
+  *dip = *ip;
+  wsect(bn, buf);
+}
+
+void
+rinode(uint inum, struct dinode *ip)
+{
+  char buf[BSIZE];
+  uint bn;
+  struct dinode *dip;
+
+  bn = IBLOCK(inum, sb);
+  rsect(bn, buf);
+  dip = ((struct dinode*)buf) + (inum % IPB);
+  *ip = *dip;
+}
+
+void
+rsect(uint sec, void *buf)
+{
+  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE)
+    die("lseek");
+  if(read(fsfd, buf, BSIZE) != BSIZE)
+    die("read");
+}
+
+uint
+ialloc(ushort type)
+{
+  uint inum = freeinode++;
+  struct dinode din;
+
+  bzero(&din, sizeof(din));
+  din.type = xshort(type);
+  din.nlink = xshort(1);
+  din.size = xint(0);
+  winode(inum, &din);
+  return inum;
+}
+
+void
+balloc(int used)
+{
+  uchar buf[BSIZE];
+  int i;
+
+  printf("balloc: first %d blocks have been allocated\n", used);
+  assert(used < BSIZE*8);
+  bzero(buf, BSIZE);
+  for(i = 0; i < used; i++){
+    buf[i/8] = buf[i/8] | (0x1 << (i%8));
+  }
+  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
+  wsect(sb.bmapstart, buf);
+}
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+
+void
+iappend(uint inum, void *xp, int n)
+{
+  char *p = (char*)xp;
+  uint fbn, off, n1;
+  struct dinode din;
+  char buf[BSIZE];
+  uint indirect[NINDIRECT];
+  uint x;
+
+  rinode(inum, &din);
+  off = xint(din.size);
+  /* printf("append inum %d at off %d sz %d\n", inum, off, n); */
+  while(n > 0){
+    fbn = off / BSIZE;
+    assert(fbn < MAXFILE);
+    if(fbn < NDIRECT){
+      if(xint(din.addrs[fbn]) == 0){
+        din.addrs[fbn] = xint(freeblock++);
+      }
+      x = xint(din.addrs[fbn]);
+    } else {
+      if(xint(din.addrs[NDIRECT]) == 0){
+        din.addrs[NDIRECT] = xint(freeblock++);
+      }
+      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+      if(indirect[fbn - NDIRECT] == 0){
+        indirect[fbn - NDIRECT] = xint(freeblock++);
+        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+      }
+      x = xint(indirect[fbn-NDIRECT]);
+    }
+    n1 = min(n, (fbn + 1) * BSIZE - off);
+    rsect(x, buf);
+    bcopy(p, buf + off - (fbn * BSIZE), n1);
+    wsect(x, buf);
+    n -= n1;
+    off += n1;
+    p += n1;
+  }
+  din.size = xint(off);
+  winode(inum, &din);
+}
+
+void
+die(const char *s)
+{
+  perror(s);
+  exit(1);
+}
diff --git a/xv6-riscv/user/RRTest.c b/xv6-riscv/user/RRTest.c
new file mode 100644
index 0000000..d71aa9b
--- /dev/null
+++ b/xv6-riscv/user/RRTest.c
@@ -0,0 +1,111 @@
+/*
+ NAME: Matthew Munro
+ NSID: mam552
+ STUDENT NUMBER: 11291769
+ NAME: Yi Luan
+ NSID: yil160
+ STUDENT NUMBER: 11253856
+ CMPT 332 2022
+ A3
+*/
+#include "kernel/types.h"
+#include "user/user.h"
+
+
+
+int
+do_rand(unsigned long *ctx)
+{
+/*
+ * Compute x = (7^5 * x) mod (2^31 - 1)
+ * without overflowing 31 bits:
+ *      (2^31 - 1) = 127773 * (7^5) + 2836
+ * From "Random number generators: good ones are hard to find",
+ * Park and Miller, Communications of the ACM, vol. 31, no. 10,
+ * October 1988, p. 1195.
+ */
+    long hi, lo, x;
+
+    /* Transform to [1, 0x7ffffffe] range. */
+    x = (*ctx % 0x7ffffffe) + 1;
+    hi = x / 127773;
+    lo = x % 127773;
+    x = 16807 * lo - 2836 * hi;
+    if (x < 0)
+        x += 0x7fffffff;
+    /* Transform to [0, 0x7ffffffd] range. */
+    x--;
+    *ctx = x;
+    return (x);
+}
+
+unsigned long rand_next = 1;
+
+int
+rand(void)
+{
+    rand_next+= getpid();
+    return do_rand(&rand_next);
+}
+
+int fib(int num){
+    if (num <= 2) {
+        return 1;
+    }
+    // printf(  "Process: %d  is runnig prior %d\n",getpid(),getpriority());
+    // printf("Process: %d  is runnig\n",getpid());
+
+
+    return fib(num - 1) + fib(num - 2);
+}
+
+void do_nice(int incr){
+  if (nice(incr)!=-1)
+  {
+      printf("Successfully increment %d priority to process %d \n",incr
+      ,getpid());
+  }else
+  {
+      // printf("Failed to change process %d priority by num using nice()\n"
+      // ,getpid());
+  }
+}
+
+void runTest(int numproc){
+    int tempid;
+    int i;
+
+    for (i = 0; i < numproc; i++) {
+      tempid = fork();
+      /* child in an infinite loop make parent possible */
+      if (tempid==0) {
+        while(1){
+          int randSleep = rand() % 5;
+          int randFib = rand() % 40;
+          int niceProb = rand() % 10;
+          int randNice = rand() % 4 + 1;
+
+          //printf("Process %d get sleep for %d time\n",getpid(),randSleep);
+          sleep(randSleep);
+          //printf("Process %d wake up, prior is %d\n",getpid(),getpriority());
+          if (niceProb == 1)
+          {
+              do_nice(randNice);
+          }
+          printf("Process %d before running fib(%d) prior is %d\n"
+          ,getpid(),randFib,getpriority());
+          fib(randFib);
+
+
+        };
+      }else if (tempid == -1) {
+        printf("Fail to create new process\n" );
+      }
+  }
+}
+
+
+int main() {
+  runTest(5);
+  return 0;
+}
diff --git a/xv6-riscv/user/cowtest.c b/xv6-riscv/user/cowtest.c
new file mode 100644
index 0000000..281c090
--- /dev/null
+++ b/xv6-riscv/user/cowtest.c
@@ -0,0 +1,168 @@
+/* */
+/* tests for copy-on-write fork() assignment. */
+/* */
+#include "kernel/types.h"
+#include "kernel/memlayout.h"
+#include "user/user.h"
+/* allocate more than half of physical memory, */
+/* then fork. this will fail in the default */
+/* kernel, which does not support copy-on-write. */
+void
+simpletest()
+{
+  uint64 phys_size = PHYSTOP - KERNBASE;
+  int sz = (phys_size / 3) * 2;
+  printf("simple: ");
+  
+  char *p = sbrk(sz);
+  if(p == (char*)0xffffffffffffffffL){
+    printf("sbrk(%d) failed\n", sz);
+    exit(-1);
+  }
+  for(char *q = p; q < p + sz; q += 4096){
+    *(int*)q = getpid();
+  }
+  int pid = fork();
+  if(pid < 0){
+    printf("fork() failed\n");
+    exit(-1);
+  }
+  if(pid == 0) {
+    exit(0);
+  }
+  wait(0);
+  if(sbrk(-sz) == (char*)0xffffffffffffffffL){
+    printf("sbrk(-%d) failed\n", sz);
+    exit(-1);
+  }
+  printf("ok\n");
+}
+/* three processes all write COW memory. */
+/* this causes more than half of physical memory */
+/* to be allocated, so it also checks whether */
+/* copied pages are freed. */
+void
+threetest()
+{
+  uint64 phys_size = PHYSTOP - KERNBASE;
+  int sz = phys_size / 4;
+  int pid1, pid2;
+  printf("three: ");
+  
+  char *p = sbrk(sz);
+  if(p == (char*)0xffffffffffffffffL){
+    printf("sbrk(%d) failed\n", sz);
+    exit(-1);
+  }
+  pid1 = fork();
+  if(pid1 < 0){
+    printf("fork failed\n");
+    exit(-1);
+  }
+  if(pid1 == 0){
+    pid2 = fork();
+    if(pid2 < 0){
+      printf("fork failed");
+      exit(-1);
+    }
+    if(pid2 == 0){
+      for(char *q = p; q < p + (sz/5)*4; q += 4096){
+        *(int*)q = getpid();
+      }
+      for(char *q = p; q < p + (sz/5)*4; q += 4096){
+        if(*(int*)q != getpid()){
+          printf("wrong content\n");
+          exit(-1);
+        }
+      }
+      exit(-1);
+    }
+    for(char *q = p; q < p + (sz/2); q += 4096){
+      *(int*)q = 9999;
+    }
+    exit(0);
+  }
+  for(char *q = p; q < p + sz; q += 4096){
+    *(int*)q = getpid();
+  }
+  wait(0);
+  sleep(1);
+  for(char *q = p; q < p + sz; q += 4096){
+    if(*(int*)q != getpid()){
+      printf("wrong content\n");
+      exit(-1);
+    }
+  }
+  if(sbrk(-sz) == (char*)0xffffffffffffffffL){
+    printf("sbrk(-%d) failed\n", sz);
+    exit(-1);
+  }
+  printf("ok\n");
+}
+char junk1[4096];
+int fds[2];
+char junk2[4096];
+char buf[4096];
+char junk3[4096];
+/* test whether copyout() simulates COW faults. */
+void
+filetest()
+{
+  printf("file: ");
+  
+  buf[0] = 99;
+  for(int i = 0; i < 4; i++){
+    if(pipe(fds) != 0){
+      printf("pipe() failed\n");
+      exit(-1);
+    }
+    int pid = fork();
+    if(pid < 0){
+      printf("fork failed\n");
+      exit(-1);
+    }
+    if(pid == 0){
+      sleep(1);
+      if(read(fds[0], buf, sizeof(i)) != sizeof(i)){
+        printf("error: read failed\n");
+        exit(1);
+      }
+      sleep(1);
+      int j = *(int*)buf;
+      if(j != i){
+        printf("error: read the wrong value\n");
+        exit(1);
+      }
+      exit(0);
+    }
+    if(write(fds[1], &i, sizeof(i)) != sizeof(i)){
+      printf("error: write failed\n");
+      exit(-1);
+    }
+  }
+  int xstatus = 0;
+  for(int i = 0; i < 4; i++) {
+    wait(&xstatus);
+    if(xstatus != 0) {
+      exit(1);
+    }
+  }
+  if(buf[0] != 99){
+    printf("error: child overwrote parent\n");
+    exit(1);
+  }
+  printf("ok\n");
+}
+int
+main(int argc, char *argv[])
+{
+  simpletest();
+  /* check that the first simpletest() freed the physical memory. */
+  simpletest();
+  threetest();
+  threetest();
+  threetest();
+  filetest();
+  printf("ALL COW TESTS PASSED\n");
+  exit(0);
+}
\ No newline at end of file
diff --git a/xv6-riscv/user/user.h b/xv6-riscv/user/user.h
index ea1d5a5..1db235f 100644
--- a/xv6-riscv/user/user.h
+++ b/xv6-riscv/user/user.h
@@ -22,6 +22,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+/* CMPT 332 GROUP 22 Change, Fall 2022 */
+uint64 getNumPages(void);
+int nice(int);
+int getpriority();
 
 /* ulib.c */
 int stat(const char*, struct stat*);
diff --git a/xv6-riscv/user/usys.pl b/xv6-riscv/user/usys.pl
index 01e426e..d267b90 100755
--- a/xv6-riscv/user/usys.pl
+++ b/xv6-riscv/user/usys.pl
@@ -36,3 +36,7 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+# CMPT 332 GROUP 22 Change, Fall 2022
+entry("getNumPages");
+entry("nice");
+entry("getpriority")
