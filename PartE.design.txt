/*
# NAME: Matthew Munro
# NSID: mam552
# STUDENT NUMBER: 11291769
# NAME: Yi Luan
# NSID: yil160
# STUDENT NUMBER: 11253856
# CMPT 332 2022
# A1 Phase 2
*/

The basic design involves a loop driven by an infinite loop that prints a
prompt and waits for lines from stdin. When it receives a new command, the
tokenizer (via strtok()) splits the command into tokens for later processing by
the shell. The tokenizer can handle an arbitrary length of tokens per command,
by dynamically reallocating space in the token array as needed. The token
array is null-terminated to conform with how exec calls determine the end of
an array of arguments. The prompt and cd builtin uses unistd.h to interface
with the POSIX OS API. The exit builtin is very simple and just calls exit().

  execute():
      If the path is included in the command, directly path that to execv().
      Use a while loop to iterate through all PATH hard coded in the path array
      and concatenate the path and command using memmove(). Path that concated
      command to the c-library function execv(). Try command in every path, if
      failed(return == -1), try next path. Print error message after tried all
      PATH.

      PARAMETERS:
            char **tokenArr: an string array that contains command user
            typed in shell.
            char **path: the path the command will be searched from.

      PRECONDITION: NONE;

      FUNCITONING:  execute command(program) in hard coded path.

      POSTCONDITION: NONE.

      RETURNS: NONE.

For the part of implementing pipe feature. First, detect if there is only one
pipe character in the command. If so, split the command bypipe character using
memmove(), and send them to the execute() function after adding NULL to the end
of first half command. fork() and execute the leading command first, save the
output to a temperary file called "temp.txt" using dup2(). Wait until it finish
, fork again to execute the next command, use dup2() to read input from the
temp file just saved. Remove the file after it done.


    update_cwd:
        Determines the current working directory of the process, and
        updates the prompt to reflect the new current working directory,
        if such a change had occured.
    PARAMS:
        char **prompt: A pointer that will point to memory containing the
        new current working directory.
        size_t *promptSize: An integer that will be set to the new length
        of the prompt string.


    get_line:
        Gets a single line from stdin, excluding newline but including
        null terminator.
    PARAMS:
        char **command: A pointer that will point to memory containing
        the new line.
        size_t bufSize: The size, in bytes, of the memory pointed to
        by command. If the new line is larger than bufSize, command
        is reallocated to fit and the new bufSize is written into
        the parameter.
